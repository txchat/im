// Code generated by goctl. DO NOT EDIT.
// Source: logic.proto

package logic

import (
	"context"

	"github.com/txchat/im/api/logic"
	"github.com/zeromicro/go-zero/zrpc"
	"google.golang.org/grpc"
)

type (
	ConnectReply       = logic.ConnectReply
	ConnectReq         = logic.ConnectReq
	DelGroupReq        = logic.DelGroupReq
	DisconnectReq      = logic.DisconnectReq
	HeartbeatReq       = logic.HeartbeatReq
	JoinGroupByKeyReq  = logic.JoinGroupByKeyReq
	JoinGroupByUIDReq  = logic.JoinGroupByUIDReq
	LeaveGroupByKeyReq = logic.LeaveGroupByKeyReq
	LeaveGroupByUIDReq = logic.LeaveGroupByUIDReq
	PushByKeyReq       = logic.PushByKeyReq
	PushByUIDReq       = logic.PushByUIDReq
	PushGroupReq       = logic.PushGroupReq
	ReceiveReq         = logic.ReceiveReq
	ReceivedMessage    = logic.ReceivedMessage
	Reply              = logic.Reply

	Logic interface {
		Connect(ctx context.Context, in *ConnectReq, opts ...grpc.CallOption) (*ConnectReply, error)
		Disconnect(ctx context.Context, in *DisconnectReq, opts ...grpc.CallOption) (*Reply, error)
		Heartbeat(ctx context.Context, in *HeartbeatReq, opts ...grpc.CallOption) (*Reply, error)
		Receive(ctx context.Context, in *ReceiveReq, opts ...grpc.CallOption) (*Reply, error)
		PushByUID(ctx context.Context, in *PushByUIDReq, opts ...grpc.CallOption) (*Reply, error)
		PushByKey(ctx context.Context, in *PushByKeyReq, opts ...grpc.CallOption) (*Reply, error)
		PushGroup(ctx context.Context, in *PushGroupReq, opts ...grpc.CallOption) (*Reply, error)
		JoinGroupByKey(ctx context.Context, in *JoinGroupByKeyReq, opts ...grpc.CallOption) (*Reply, error)
		JoinGroupByUID(ctx context.Context, in *JoinGroupByUIDReq, opts ...grpc.CallOption) (*Reply, error)
		LeaveGroupByKey(ctx context.Context, in *LeaveGroupByKeyReq, opts ...grpc.CallOption) (*Reply, error)
		LeaveGroupByUID(ctx context.Context, in *LeaveGroupByUIDReq, opts ...grpc.CallOption) (*Reply, error)
		DelGroup(ctx context.Context, in *DelGroupReq, opts ...grpc.CallOption) (*Reply, error)
	}

	defaultLogic struct {
		cli zrpc.Client
	}
)

func NewLogic(cli zrpc.Client) Logic {
	return &defaultLogic{
		cli: cli,
	}
}

func (m *defaultLogic) Connect(ctx context.Context, in *ConnectReq, opts ...grpc.CallOption) (*ConnectReply, error) {
	client := logic.NewLogicClient(m.cli.Conn())
	return client.Connect(ctx, in, opts...)
}

func (m *defaultLogic) Disconnect(ctx context.Context, in *DisconnectReq, opts ...grpc.CallOption) (*Reply, error) {
	client := logic.NewLogicClient(m.cli.Conn())
	return client.Disconnect(ctx, in, opts...)
}

func (m *defaultLogic) Heartbeat(ctx context.Context, in *HeartbeatReq, opts ...grpc.CallOption) (*Reply, error) {
	client := logic.NewLogicClient(m.cli.Conn())
	return client.Heartbeat(ctx, in, opts...)
}

func (m *defaultLogic) Receive(ctx context.Context, in *ReceiveReq, opts ...grpc.CallOption) (*Reply, error) {
	client := logic.NewLogicClient(m.cli.Conn())
	return client.Receive(ctx, in, opts...)
}

func (m *defaultLogic) PushByUID(ctx context.Context, in *PushByUIDReq, opts ...grpc.CallOption) (*Reply, error) {
	client := logic.NewLogicClient(m.cli.Conn())
	return client.PushByUID(ctx, in, opts...)
}

func (m *defaultLogic) PushByKey(ctx context.Context, in *PushByKeyReq, opts ...grpc.CallOption) (*Reply, error) {
	client := logic.NewLogicClient(m.cli.Conn())
	return client.PushByKey(ctx, in, opts...)
}

func (m *defaultLogic) PushGroup(ctx context.Context, in *PushGroupReq, opts ...grpc.CallOption) (*Reply, error) {
	client := logic.NewLogicClient(m.cli.Conn())
	return client.PushGroup(ctx, in, opts...)
}

func (m *defaultLogic) JoinGroupByKey(ctx context.Context, in *JoinGroupByKeyReq, opts ...grpc.CallOption) (*Reply, error) {
	client := logic.NewLogicClient(m.cli.Conn())
	return client.JoinGroupByKey(ctx, in, opts...)
}

func (m *defaultLogic) JoinGroupByUID(ctx context.Context, in *JoinGroupByUIDReq, opts ...grpc.CallOption) (*Reply, error) {
	client := logic.NewLogicClient(m.cli.Conn())
	return client.JoinGroupByUID(ctx, in, opts...)
}

func (m *defaultLogic) LeaveGroupByKey(ctx context.Context, in *LeaveGroupByKeyReq, opts ...grpc.CallOption) (*Reply, error) {
	client := logic.NewLogicClient(m.cli.Conn())
	return client.LeaveGroupByKey(ctx, in, opts...)
}

func (m *defaultLogic) LeaveGroupByUID(ctx context.Context, in *LeaveGroupByUIDReq, opts ...grpc.CallOption) (*Reply, error) {
	client := logic.NewLogicClient(m.cli.Conn())
	return client.LeaveGroupByUID(ctx, in, opts...)
}

func (m *defaultLogic) DelGroup(ctx context.Context, in *DelGroupReq, opts ...grpc.CallOption) (*Reply, error) {
	client := logic.NewLogicClient(m.cli.Conn())
	return client.DelGroup(ctx, in, opts...)
}
